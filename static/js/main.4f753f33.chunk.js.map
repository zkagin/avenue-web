{"version":3,"sources":["Components/Coordinate.jsx","Components/Square.js","Components/Grid.js","Components/Graph.tsx","Components/Game.js","Components/App.js","index.js"],"names":["Coordinate","x","y","Object","classCallCheck","this","Square","props","react_default","a","createElement","className","selected","answer","style","width","dimension","height","lineHeight","fontSize","backgroundColor","value","isEnd","Grid","squares","square_dimension","size","newSquare","Components_Square","key","gameState","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","history","Symbol","iterator","next","done","coordinate","React","cloneElement","err","return","optimalPath","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","push","Component","GraphNode","distanceToNode","previousNode","Number","MAX_SAFE_INTEGER","getAdjacentNodes","node","allNodes","adjacentNodes","valueOf","length","getOptimalPath","nodes","unvisitedNodes","row","column","currentNode","shift","newNode","includes","currentDistance","newDistance","sort","b","shortestPath","pathTotal","Game","_this","possibleConstructorReturn","getPrototypeOf","call","state","currentPath","newGameState","level","handleKeyDown","bind","assertThisInitialized","window","addEventListener","removeEventListener","event","keyCode","isGameOver","setState","currentCoordinate","slice","priorCoordinate","newX","newY","newPath","pop","isAlreadyInPath","handleGameOver","optimalPathResponse","getCurrentPathScore","onCompletedLevel","Math","floor","random","score","title","id","Components_Grid","App","cookies","parseInt","get","set","Components_Game","withCookies","ReactDOM","render","es6","Components_App","document","getElementById"],"mappings":"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","file":"static/js/main.4f753f33.chunk.js","sourcesContent":["class Coordinate {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nexport default Coordinate;\n","import React from \"react\";\nimport \"./styles.css\";\n\nfunction Square(props) {\n  return (\n    <div\n      className={\n        \"Square\" +\n        (props.selected ? \" selected\" : \"\") +\n        (props.answer ? \" answer\" : \"\")\n      }\n      style={{\n        width: props.dimension - 0.1 + \"rem\",\n        height: props.dimension - 0.1 + \"rem\",\n        lineHeight: props.dimension + \"rem\",\n        fontSize: props.dimension * 6,\n        backgroundColor: color(props.value)\n      }}\n    >\n      {props.isEnd ? \"End\" : props.value}\n    </div>\n  );\n}\n\nfunction color(value) {\n  const colorRed = 200 - value * 15;\n  const colorGreen = 200 - value * 15;\n  const colorBlue = 270 - value * 15;\n  return \"rgb(\" + colorRed + \",\" + colorGreen + \",\" + colorBlue + \")\";\n}\n\nexport default Square;\n","import React from \"react\";\nimport \"./styles.css\";\nimport Square from \"./Square\";\n\nclass Grid extends React.Component {\n  render() {\n    const squares = [];\n    const dimension = 30;\n    const square_dimension = dimension / this.props.size;\n    for (let y = 1; y <= this.props.size; y++) {\n      for (let x = 1; x <= this.props.size; x++) {\n        let newSquare = (\n          <Square\n            key={x + \",\" + y}\n            value={this.props.gameState[y - 1][x - 1]}\n            dimension={square_dimension}\n            isEnd={x === this.props.size && y === this.props.size}\n          />\n        );\n        for (let coordinate of this.props.history) {\n          if (coordinate.x === x && coordinate.y === y) {\n            newSquare = React.cloneElement(newSquare, { selected: true });\n          }\n        }\n        if (this.props.optimalPath != null) {\n          for (let coordinate of this.props.optimalPath) {\n            if (coordinate.x === x && coordinate.y === y) {\n              newSquare = React.cloneElement(newSquare, { answer: true });\n            }\n          }\n        }\n        squares.push(newSquare);\n      }\n    }\n    return (\n      <div\n        className=\"Grid\"\n        style={{ width: dimension + \"rem\", height: dimension + \"rem\" }}\n      >\n        {squares}\n      </div>\n    );\n  }\n}\n\nexport default Grid;\n","import Coordinate from \"./Coordinate\";\n\nclass GraphNode {\n  x: number;\n  y: number;\n  value: number;\n  distanceToNode: number;\n  previousNode: GraphNode | null;\n  constructor(x: number, y: number, value: number) {\n    this.x = x;\n    this.y = y;\n    this.value = value;\n    this.distanceToNode = Number.MAX_SAFE_INTEGER;\n    this.previousNode = null;\n  }\n}\n\nfunction getOptimalPath(gameState: Array<Array<number>>) {\n  // Initialization\n  let nodes: Array<Array<GraphNode>> = [];\n  let unvisitedNodes: Array<GraphNode> = [];\n  for (let row = 0; row < gameState.length; row++) {\n    nodes[row] = [];\n    for (let column = 0; column < gameState.length; column++) {\n      const value: number = gameState[row][column];\n      let node: GraphNode = new GraphNode(column, row, value);\n      nodes[row].push(node);\n      unvisitedNodes.push(node);\n    }\n  }\n\n  // Grab the first node, which is the start node.\n  let currentNode: GraphNode = unvisitedNodes.shift()!;\n  currentNode.distanceToNode = 0;\n\n  // Continue going through nodes until the exit node is reached.\n  while (\n    !(\n      currentNode.x === gameState.length - 1 &&\n      currentNode.y === gameState.length - 1\n    )\n  ) {\n    // Go through all of the current node's unvisited edges and update their distances.\n    for (let newNode of getAdjacentNodes(currentNode, nodes)) {\n      if (unvisitedNodes.includes(newNode)) {\n        const currentDistance = newNode.distanceToNode;\n        const newDistance = currentNode.distanceToNode + newNode.value;\n        if (newDistance < currentDistance) {\n          newNode.distanceToNode = newDistance;\n          newNode.previousNode = currentNode;\n        }\n      }\n    }\n\n    // Get the next node, which is the one with the minimum distance to it.\n    unvisitedNodes.sort(function(a, b) {\n      return a.distanceToNode - b.distanceToNode;\n    });\n    currentNode = unvisitedNodes.shift()!;\n  }\n\n  // Trace the path back from the last node.\n  let shortestPath: Array<Coordinate> = [];\n  let pathTotal = 0;\n  while (true) {\n    shortestPath.push(new Coordinate(currentNode.x + 1, currentNode.y + 1));\n    pathTotal += currentNode.value;\n    if (currentNode.previousNode != null) {\n      currentNode = currentNode.previousNode;\n    } else {\n      break;\n    }\n  }\n\n  return [shortestPath, pathTotal];\n}\n\nfunction getAdjacentNodes(node: GraphNode, allNodes: Array<Array<GraphNode>>) {\n  let adjacentNodes: Array<GraphNode> = [];\n  const x = node.x.valueOf();\n  const y = node.y.valueOf();\n\n  // Add adjacent nodes if not on the left, top, right, or bottom edge.\n  if (node.y > 0) adjacentNodes.push(allNodes[y - 1][x]);\n  if (node.x > 0) adjacentNodes.push(allNodes[y][x - 1]);\n  if (node.y < allNodes.length - 1) adjacentNodes.push(allNodes[y + 1][x]);\n  if (node.x < allNodes.length - 1) adjacentNodes.push(allNodes[y][x + 1]);\n  return adjacentNodes;\n}\n\nexport default getOptimalPath;\n","import React from \"react\";\nimport \"./styles.css\";\nimport Coordinate from \"./Coordinate\";\nimport Grid from \"./Grid\";\nimport getOptimalPath from \"./Graph\";\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      currentPath: [new Coordinate(1, 1)],\n      gameState: this.newGameState(this.props.level),\n      optimalPath: null\n    };\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n  }\n\n  componentDidMount() {\n    window.addEventListener(\"keydown\", this.handleKeyDown);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"keydown\", this.handleKeyDown);\n  }\n\n  handleKeyDown(event) {\n    const keyCode = event.keyCode;\n    if (this.isGameOver() && keyCode === 32) {\n      this.setState({\n        currentPath: [new Coordinate(1, 1)],\n        gameState: this.newGameState(this.props.level),\n        optimalPath: null\n      });\n    } else if (this.isGameOver() || keyCode > 40 || keyCode < 37) return;\n\n    let currentCoordinate = this.state.currentPath.slice(-1)[0];\n    let priorCoordinate = this.state.currentPath.slice(-2, -1)[0];\n    let newX = currentCoordinate.x;\n    let newY = currentCoordinate.y;\n    switch (keyCode) {\n      case 37: // Left Arrow\n        if (newX > 1) newX--;\n        break;\n      case 38: // Up Arrow\n        if (newY > 1) newY--;\n        break;\n      case 39: // Right Arrow\n        if (newX < this.props.level) newX++;\n        break;\n      case 40: // Down Arrow\n        if (newY < this.props.level) newY++;\n        break;\n      default:\n    }\n\n    if (newX === currentCoordinate.x && newY === currentCoordinate.y) {\n      // No move (user is at an edge)\n    } else if (\n      priorCoordinate &&\n      newX === priorCoordinate.x &&\n      newY === priorCoordinate.y\n    ) {\n      // Move is going backwards, so undo the move.\n      let newPath = this.state.currentPath.slice();\n      newPath.pop();\n      this.setState({\n        currentPath: newPath,\n        gameState: this.state.gameState,\n        optimalPath: this.state.optimalPath\n      });\n    } else if (this.isAlreadyInPath(newX, newY)) {\n      // Move collides with an existing coordinate.\n    } else {\n      // Move is going forward.\n      let newPath = this.state.currentPath.slice();\n      newPath.push(new Coordinate(newX, newY));\n      this.setState({\n        currentPath: newPath,\n        gameState: this.state.gameState,\n        optimalPath: this.state.optimalPath\n      });\n    }\n\n    this.handleGameOver();\n  }\n\n  isGameOver() {\n    let currentCoordinate = this.state.currentPath.slice(-1)[0];\n    return (\n      currentCoordinate.x === this.props.level &&\n      currentCoordinate.y === this.props.level\n    );\n  }\n\n  handleGameOver() {\n    if (this.isGameOver()) {\n      const optimalPathResponse = getOptimalPath(this.state.gameState);\n      const currentPathScore = this.getCurrentPathScore();\n      if (currentPathScore === optimalPathResponse[1]) {\n        this.props.onCompletedLevel();\n      } else {\n        this.setState({\n          currentPath: this.state.currentPath,\n          gameState: this.state.gameState,\n          optimalPath: optimalPathResponse[0]\n        });\n      }\n    }\n  }\n\n  isAlreadyInPath(newX, newY) {\n    for (let coordinate of this.state.currentPath) {\n      if (newX === coordinate.x && newY === coordinate.y) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  newGameState(size) {\n    let gameState = [];\n    for (let y = 0; y < size; y++) {\n      gameState[y] = [];\n      for (let x = 0; x < size; x++) {\n        gameState[y][x] = Math.floor(Math.random() * 5) + 1;\n      }\n    }\n    return gameState;\n  }\n\n  getCurrentPathScore() {\n    let score = 0;\n    for (let coordinate of this.state.currentPath) {\n      score += this.state.gameState[coordinate.y - 1][coordinate.x - 1];\n    }\n    return score;\n  }\n\n  render() {\n    const title = this.isGameOver()\n      ? \"Press Space to try again.\"\n      : \"Level \" + this.props.level;\n    return (\n      <div>\n        <div id=\"title\">{title}</div>\n        <div className=\"Game\">\n          <Grid\n            size={this.props.level}\n            history={this.state.currentPath}\n            gameState={this.state.gameState}\n            optimalPath={this.state.optimalPath}\n          />\n        </div>\n        <div id=\"instructions\">\n          Get to the bottom right corner with the smallest sum of numbers.\n          <br />\n          Use arrow keys to move.\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Game;\n","import React from \"react\";\nimport Game from \"./Game\";\nimport \"./styles.css\";\nimport { Cookies, withCookies } from \"react-cookie\";\nimport { instanceOf } from \"prop-types\";\n\nclass App extends React.Component {\n  static propTypes = {\n    cookies: instanceOf(Cookies).isRequired\n  };\n\n  constructor(props) {\n    super(props);\n    const { cookies } = props;\n    this.onCompletedLevel = this.onCompletedLevel.bind(this);\n    this.state = {\n      level: parseInt(cookies.get(\"maxLevel\")) || 3\n    };\n  }\n\n  onCompletedLevel() {\n    const { cookies } = this.props;\n    cookies.set(\"maxLevel\", this.state.level + 1);\n    this.setState({\n      level: this.state.level + 1\n    });\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <Game\n          level={this.state.level}\n          onCompletedLevel={this.onCompletedLevel}\n          key={this.state.level}\n        />\n      </div>\n    );\n  }\n}\n\nexport default withCookies(App);\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./Components/App\";\nimport { CookiesProvider } from \"react-cookie\";\n\nReactDOM.render(\n  <CookiesProvider>\n    <App />\n  </CookiesProvider>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}